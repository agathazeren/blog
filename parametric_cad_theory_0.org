#+title: Some Thoughts on the Nature of Parametric CAD
In most parametric CAD systems, there are two sorts of geometry. Firstly, there is /solved/ geometry, where a system of geometric objects, such as points, planes, etc. are defined by constraints among them, such as coincident, distance, etc. Secondly there is /procedural/ geometry, where geometry is modified by a series of functions, such as extrude, fillet, etc. There is also the notion of sketches, parts, and assemblies, but this is a different concept than the one I want to discuss in this article. Depending on the system, whether each of these are solved or procedural changes, though sketches are almost always solved, and parts almost always procedural.
* A brief note on my qualifications
TL;DR: Just enough to be dangerous

I just want to mention that I have only worked in parametric CAD for around four years, and only with two systems, PTC Creo and OnShape. I would defiantly not consider myself a CAD expert, though I am also not incompetent. Also, towards the end of this article I touch on mathematical concepts that I have only a surface understanding of. 

Also it's worth noting that I couldn't find any prior art in the theory of CAD, but I also didn't look very hard. Perhaps this has all been thought of before. 
* Eliminating /procedural/ geometry
The key difference between /solved/ and /procedural/ geometry is time. Or rather, a linear dependence. In /procedural/ geometry, each feature brings the model from one state to another, adding, removing, or changing some part of the geometry. This is a powerful model. Think about a fillet or round feature. This feature may seem trivial, but think about when you fillet on an inside corner. Or when several fillets join together. Or when part of a fillet intersects a hole. Most likely your CAD program handles these cases, or some even more complex cases, just fine. But just think for a moment on how complicated fillet is. Trying to express this naively in a constraint based model is very hard. Now try to imagine a sweep on a curve defined by an arbitrary equation, that may even self intersect. 

/Solved/ geometry is just as baffling to represent as /procedural/. While circular references are dreaded when working in procedural geometry, they are the bread and butter of solved geometry. Even something as simple as the four lines that make up a rectangle is circular, as each line is constrained to its two neighbors.

If we take a step back though, we can see a way to reconcile these two notions. Constraints in solved geometry are expressing a relationship between several objects. Features in procedural geometry are also expressing a relationship, but just in a slightly different way. They express a relationship across /time/. We can actually eliminate this parameter though, by making both the past and present objects exist at the same time. So, to express a fillet, both the original unfilled object and the filleted object would exist, and there would be a =is a copy of but filleted= constraint between them. 

This is how procedural geometry is eliminated conceptually, but do note that while that tactic is probably still used for procedural style geometry, in practice the workflow probably will not work like this. 
* Implications for the representation of objects
   This model has interesting implications for the representation of objects. In particular, the representation of solids. While geometry such as points or lines have a uniform structure, a solid is a highly structured piece of geometry. This rigid model of a solid is incompatible with the representation of traditionally procedural features as constraints. What the internal structure of an solid looks like (its faces, edges, etc.) is dependent on what it is extruded from. Thus, a solid must be represented only by what it is constrained, and without constraints it must be an amorphous space (that takes up neither infinite nor finite space).
* You may have already been thinking this way
   If you, like me, often use the "Intersect" mode of the Extrude tool in OnShape, boolean operations, or tools like this, you may have been already thinking like this. Also, if you've drawn hand drawings, you may have already been thinking like this. 
* Connections to generative design
   One of the advancements in engineering design is "generative design", which is a method of design where you constrain the design and then an algorithm will fill in the details. Especially with the rise of additive manufacturing, this can lead to highly optimized designs being created much faster than hand-optimization.
   This method of specifying designs is especially conducive to this, as non-generative modeling is still done through a constraint based architecture. Not having a strong delineation between generative and classical parts is especially important for gradual adoption, and also for the ability to work with generative parts through classical modeling. 
* One step further
  This model can be extended one step further, by making the species of objects determined by constraints, and not be inherent to the object. So instead of an object having an inherent property of being a solid, the object would just be an object, with a constraint =is a solid= pointing at it. 
* Hey, this is also... (implementation)
  There is actually implementation precedent for this kind of system: entity-component systems. This architecture, first designed for video games to improve performance and maintainability, is actually very strongly mapped to the model of geometry described herein. There are two differences. First, while components normally only belong to a single entity, constraints are attached to multiple objects. Secondly, there is the additional notion of derived constraints. However, I do not think that either of these make the implementation fundamentally harder.
* Hey, this is almost, but not quite... (math)
  Also, I noticed that this is almost a category. It isn't quite, but the resemblance is interesting.
* (Possible) extension: Unifying constraints and objects.
  One possible extension of this model is to unify constraints and objects, and have a single "member of" relation. However, this proves difficult to design elegantly for some constraints, and there are more type issues with this system, and so I do not at this time think it is the right direction, though it is an interesting one to consider. 
